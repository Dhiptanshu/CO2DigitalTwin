<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Delhi Map - Three.js</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#111; }
    #status {
      position:absolute;
      top:10px;
      left:10px;
      color:white;
      z-index:10;
      font-family: sans-serif;
      font-size: 13px;
      background: rgba(0,0,0,0.4);
      padding: 6px 10px;
      border-radius: 4px;
    }
  </style>
</head>

<body>
<div id="status">
  Click to lock mouse.<br>
  Move: W/A/S/D or Arrow keys<br>
  Up: Space &nbsp; Down: Shift
</div>

<script type="module">
console.log("THREE POV FLY + CYLINDER STATIONS");

// -------- IMPORTS --------
import * as THREE from 'https://unpkg.com/three@0.126.1/build/three.module.js';
import { PointerLockControls } from 'https://unpkg.com/three@0.126.1/examples/jsm/controls/PointerLockControls.js';
import { GLTFLoader } from 'https://unpkg.com/three@0.126.1/examples/jsm/loaders/GLTFLoader.js';

// -------- STATION DATA (lat/lon) --------
const STATIONS = [
  { id: "DL001", name: "Alipur, Delhi - DPCC",           lat: 28.7041, lon: 77.1025 },
  { id: "DL002", name: "Anand Vihar, Delhi - DPCC",      lat: 28.6500, lon: 77.3150 },
  { id: "DL003", name: "Ashok Vihar, Delhi - DPCC",      lat: 28.6820, lon: 77.1670 },
  { id: "DL004", name: "Aya Nagar, Delhi - IMD",         lat: 28.5140, lon: 77.1710 },
  { id: "DL005", name: "Bawana, Delhi - DPCC",           lat: 28.7080, lon: 77.0910 },
  { id: "DL006", name: "Burari Crossing, Delhi - IMD",   lat: 28.7300, lon: 77.2100 },
  { id: "DL007", name: "CRRI Mathura Road - IMD",        lat: 28.5750, lon: 77.2560 },
  { id: "DL008", name: "DTU, Delhi - CPCB",              lat: 28.7410, lon: 77.1170 },
  { id: "DL009", name: "Dr. Karni Singh Shooting Range", lat: 28.5660, lon: 77.2160 },
];

// -------- SCENE / CAMERA / RENDERER --------
const scene = new THREE.Scene();
scene.background = new THREE.Color("#87CEEB");

const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  50000
);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// -------- POINTER LOCK CONTROLS (POV FLY) --------
const controls = new PointerLockControls(camera, document.body);

document.body.addEventListener('click', () => {
  controls.lock();
});

const move = {
  forward: false,
  backward: false,
  left: false,
  right: false,
  up: false,
  down: false,
};

const speed = 500; // movement speed

window.addEventListener('keydown', (e) => {
  if (e.key === 'w' || e.key === 'ArrowUp')    move.forward = true;
  if (e.key === 's' || e.key === 'ArrowDown')  move.backward = true;
  if (e.key === 'a' || e.key === 'ArrowLeft')  move.left = true;
  if (e.key === 'd' || e.key === 'ArrowRight') move.right = true;
  if (e.key === ' ')                           move.up = true;      // Space = up
  if (e.key === 'Shift')                       move.down = true;    // Shift = down
});

window.addEventListener('keyup', (e) => {
  if (e.key === 'w' || e.key === 'ArrowUp')    move.forward = false;
  if (e.key === 's' || e.key === 'ArrowDown')  move.backward = false;
  if (e.key === 'a' || e.key === 'ArrowLeft')  move.left = false;
  if (e.key === 'd' || e.key === 'ArrowRight') move.right = false;
  if (e.key === ' ')                           move.up = false;
  if (e.key === 'Shift')                       move.down = false;
});

// -------- LIGHTS --------
scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.5));
const dir = new THREE.DirectionalLight(0xffffff, 1);
dir.position.set(300, 400, 200);
scene.add(dir);

// -------- TEXT SPRITE HELPER (for labels) --------
function createTextSprite(message) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  const fontSize = 48;
  ctx.font = `${fontSize}px Arial`;

  const textWidth = ctx.measureText(message).width;
  canvas.width = textWidth + 40;
  canvas.height = fontSize + 30;

  ctx.font = `${fontSize}px Arial`;
  ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = 'white';
  ctx.textBaseline = 'middle';
  ctx.fillText(message, 20, canvas.height / 2);

  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;

  const material = new THREE.SpriteMaterial({
    map: texture,
    transparent: true
  });

  const sprite = new THREE.Sprite(material);

  const scaleFactor = 0.6;
  sprite.scale.set(canvas.width * scaleFactor, canvas.height * scaleFactor, 1);

  return sprite;
}

// -------- LOAD CITY MODEL --------
const loader = new GLTFLoader();
const MODEL_URL = "/models/new_delhi_india_city_and_urban.glb";

loader.load(
  MODEL_URL,
  (gltf) => {
    const model = gltf.scene;
    model.scale.set(1, 1, 1);

    // First bounding box (raw)
    const box = new THREE.Box3().setFromObject(model);
    const center = box.getCenter(new THREE.Vector3());

    // Center the model at origin
    model.position.sub(center);
    scene.add(model);

    // Recompute bounding box AFTER centering
    const centeredBox = new THREE.Box3().setFromObject(model);
    const size = centeredBox.getSize(new THREE.Vector3());

    // Place camera initially closer for fly-through feel
    camera.position.set(0, 150, 400);

    // Use centered box for markers
    addStationMarkers(centeredBox);
  },
  (xhr) => {
    // optional
  },
  (error) => {
    console.error("GLB load error", error);
    const statusEl = document.getElementById('status');
    statusEl.innerText = "Failed to load model. Check console.";
  }
);

// -------- CREATE CYLINDER STATION MARKERS + LABELS --------
function addStationMarkers(box) {
  const statusEl = document.getElementById('status');
  statusEl.innerHTML += "<br>Placing station markers...";

  // Compute lat/lon bounds from station list
  let minLat = Infinity, maxLat = -Infinity;
  let minLon = Infinity, maxLon = -Infinity;

  STATIONS.forEach(s => {
    if (s.lat < minLat) minLat = s.lat;
    if (s.lat > maxLat) maxLat = s.lat;
    if (s.lon < minLon) minLon = s.lon;
    if (s.lon > maxLon) maxLon = s.lon;
  });

  const size = box.getSize(new THREE.Vector3());

  // Approximate ground level, then lift a bit up for safety
  const groundY = box.min.y + 2;

  // Cylinder marker dimensions
  const cylRadius = Math.max(size.x, size.z) * 0.01 || 20;
  const cylHeight = Math.max(size.y * 0.08, 60); // ensure visible height

  const cylGeo = new THREE.CylinderGeometry(cylRadius, cylRadius, cylHeight, 16);
  const cylMat = new THREE.MeshStandardMaterial({
    color: 0x00ff00,
    metalness: 0.1,
    roughness: 0.5
  });

  STATIONS.forEach((s) => {
    // Normalize lat/lon to [0,1]
    const nx = (s.lon - minLon) / (maxLon - minLon + 1e-9);
    const nz = (s.lat - minLat) / (maxLat - minLat + 1e-9);

    // Map into model X/Z range, centered, with a bit of margin
    const x = (nx - 0.5) * size.x * 0.9;
    const z = - (nz - 0.5) * size.z * 0.9; // minus so "north" â‰ˆ -Z

    // ---- Vertical cylinder marker ----
    const marker = new THREE.Mesh(cylGeo, cylMat);
    // Cylinder stands on ground: center is at half height above ground
    marker.position.set(x, groundY + cylHeight / 2, z);
    marker.userData = { id: s.id, name: s.name, lat: s.lat, lon: s.lon };

    scene.add(marker);

    // ---- Label hovering above cylinder ----
    const label = createTextSprite(s.name);
    label.position.set(x, groundY + cylHeight + cylRadius * 1.5, z);

    scene.add(label);
  });

  statusEl.innerHTML += "<br>Stations added: " + STATIONS.length;
}

// -------- ANIMATION LOOP --------
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);

  const delta = clock.getDelta();
  const velocity = speed * delta;

  if (controls.isLocked) {
    if (move.forward)  controls.moveForward(velocity);
    if (move.backward) controls.moveForward(-velocity);
    if (move.left)     controls.moveRight(-velocity);
    if (move.right)    controls.moveRight(velocity);

    // Vertical movement
    if (move.up)   camera.position.y += velocity;
    if (move.down) camera.position.y -= velocity;
  }

  renderer.render(scene, camera);
}
animate();

// -------- RESIZE --------
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
